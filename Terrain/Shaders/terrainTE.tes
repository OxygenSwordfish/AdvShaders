#version 450 core

// reading in a triangle, split tesselated triangels evenly in a counter-clockwise direction (ccw)
layout(triangles, fractional_even_spacing, ccw) in;

// forward declare functions to perfrom interpolation with the barycentric coordinates from the Primitive Generator
vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2) ;
vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2) ;

float density = 0.005;
float G = 2;

// unifrom matrices to perform transformations
// previously this would have been done in vertex shader
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform sampler2D heightMap;

float heightCo = 50;

uniform vec3 eyePos;

in vec3 posTC[] ;
in vec3 normTC[] ;
in vec2 texCoordsTC[];


out vec3 normES ;
out vec3 posES ;

out float heightTE;
out float heightCoTE;

out float visibility;

void main()
{
    vec2 texCoordsTE = interpolate2D(texCoordsTC[0], texCoordsTC[1], texCoordsTC[2]);

	float right = (textureOffset(heightMap, texCoordsTE, ivec2(1,0)).r)*heightCo;
	float left = (textureOffset(heightMap, texCoordsTE, ivec2(-1,0)).r)*heightCo;
	float up = (textureOffset(heightMap, texCoordsTE, ivec2(0,1)).r)*heightCo;
	float down = (textureOffset(heightMap, texCoordsTE, ivec2(0.-1)).r)*heightCo;



	normES = interpolate3D(normTC[0], normTC[1], normTC[2]) ;

	vec3 normals = vec3 ((left-right),2.0,(up-down));
	normES = normalize(normals);
   
	posES = interpolate3D(posTC[0], posTC[1], posTC[2]) ;
	

   // transform vertex to clip space  - NOTE: WE NEED TO DO IT HERE NOW and not in vertex shader

  float height = (texture(heightMap, texCoordsTE).x);
  posES.y = height * heightCo;
  heightTE = posES.y;
  heightCoTE = heightCo;
  gl_Position = projection * view * model * vec4(posES, 1.0);


  //Fog
  float distToCam = distance(eyePos, posES);
  visibility = exp(-pow((distToCam*density),G));
  visibility = clamp(visibility, 0,1);
} 


//basic linear interpolation
vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
   	return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
   	return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

